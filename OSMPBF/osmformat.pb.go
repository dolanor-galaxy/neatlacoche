// Code generated by protoc-gen-gogo.
// source: OSMPBF/osmformat.proto
// DO NOT EDIT!

/*
	Package OSMPBF is a generated protocol buffer package.

	It is generated from these files:
		OSMPBF/osmformat.proto

	It has these top-level messages:
		HeaderBlock
		HeaderBBox
		PrimitiveBlock
		PrimitiveGroup
		StringTable
		Info
		DenseInfo
		ChangeSet
		Node
		DenseNodes
		Way
		Relation
*/
package OSMPBF

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Relation_MemberType int32

const (
	Relation_NODE     Relation_MemberType = 0
	Relation_WAY      Relation_MemberType = 1
	Relation_RELATION Relation_MemberType = 2
)

var Relation_MemberType_name = map[int32]string{
	0: "NODE",
	1: "WAY",
	2: "RELATION",
}
var Relation_MemberType_value = map[string]int32{
	"NODE":     0,
	"WAY":      1,
	"RELATION": 2,
}

func (x Relation_MemberType) Enum() *Relation_MemberType {
	p := new(Relation_MemberType)
	*p = x
	return p
}
func (x Relation_MemberType) String() string {
	return proto.EnumName(Relation_MemberType_name, int32(x))
}
func (x *Relation_MemberType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Relation_MemberType_value, data, "Relation_MemberType")
	if err != nil {
		return err
	}
	*x = Relation_MemberType(value)
	return nil
}

type HeaderBlock struct {
	Bbox *HeaderBBox `protobuf:"bytes,1,opt,name=bbox" json:"bbox,omitempty"`
	// Additional tags to aid in parsing this dataset
	RequiredFeatures []string `protobuf:"bytes,4,rep,name=required_features" json:"required_features,omitempty"`
	OptionalFeatures []string `protobuf:"bytes,5,rep,name=optional_features" json:"optional_features,omitempty"`
	Writingprogram   *string  `protobuf:"bytes,16,opt,name=writingprogram" json:"writingprogram,omitempty"`
	Source           *string  `protobuf:"bytes,17,opt,name=source" json:"source,omitempty"`
	// replication timestamp, expressed in seconds since the epoch,
	// otherwise the same value as in the "timestamp=..." field
	// in the state.txt file used by Osmosis
	OsmosisReplicationTimestamp *int64 `protobuf:"varint,32,opt,name=osmosis_replication_timestamp" json:"osmosis_replication_timestamp,omitempty"`
	// replication sequence number (sequenceNumber in state.txt)
	OsmosisReplicationSequenceNumber *int64 `protobuf:"varint,33,opt,name=osmosis_replication_sequence_number" json:"osmosis_replication_sequence_number,omitempty"`
	// replication base URL (from Osmosis' configuration.txt file)
	OsmosisReplicationBaseUrl *string `protobuf:"bytes,34,opt,name=osmosis_replication_base_url" json:"osmosis_replication_base_url,omitempty"`
}

func (m *HeaderBlock) Reset()         { *m = HeaderBlock{} }
func (m *HeaderBlock) String() string { return proto.CompactTextString(m) }
func (*HeaderBlock) ProtoMessage()    {}

func (m *HeaderBlock) GetBbox() *HeaderBBox {
	if m != nil {
		return m.Bbox
	}
	return nil
}

func (m *HeaderBlock) GetRequiredFeatures() []string {
	if m != nil {
		return m.RequiredFeatures
	}
	return nil
}

func (m *HeaderBlock) GetOptionalFeatures() []string {
	if m != nil {
		return m.OptionalFeatures
	}
	return nil
}

func (m *HeaderBlock) GetWritingprogram() string {
	if m != nil && m.Writingprogram != nil {
		return *m.Writingprogram
	}
	return ""
}

func (m *HeaderBlock) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *HeaderBlock) GetOsmosisReplicationTimestamp() int64 {
	if m != nil && m.OsmosisReplicationTimestamp != nil {
		return *m.OsmosisReplicationTimestamp
	}
	return 0
}

func (m *HeaderBlock) GetOsmosisReplicationSequenceNumber() int64 {
	if m != nil && m.OsmosisReplicationSequenceNumber != nil {
		return *m.OsmosisReplicationSequenceNumber
	}
	return 0
}

func (m *HeaderBlock) GetOsmosisReplicationBaseUrl() string {
	if m != nil && m.OsmosisReplicationBaseUrl != nil {
		return *m.OsmosisReplicationBaseUrl
	}
	return ""
}

type HeaderBBox struct {
	Left   int64 `protobuf:"zigzag64,1,req,name=left" json:"left"`
	Right  int64 `protobuf:"zigzag64,2,req,name=right" json:"right"`
	Top    int64 `protobuf:"zigzag64,3,req,name=top" json:"top"`
	Bottom int64 `protobuf:"zigzag64,4,req,name=bottom" json:"bottom"`
}

func (m *HeaderBBox) Reset()         { *m = HeaderBBox{} }
func (m *HeaderBBox) String() string { return proto.CompactTextString(m) }
func (*HeaderBBox) ProtoMessage()    {}

func (m *HeaderBBox) GetLeft() int64 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *HeaderBBox) GetRight() int64 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *HeaderBBox) GetTop() int64 {
	if m != nil {
		return m.Top
	}
	return 0
}

func (m *HeaderBBox) GetBottom() int64 {
	if m != nil {
		return m.Bottom
	}
	return 0
}

type PrimitiveBlock struct {
	StringTable    `protobuf:"bytes,1,req,name=stringtable,embedded=stringtable" json:"stringtable"`
	Primitivegroup []PrimitiveGroup `protobuf:"bytes,2,rep,name=primitivegroup" json:"primitivegroup"`
	// Granularity, units of nanodegrees, used to store coordinates in this block
	Granularity *int32 `protobuf:"varint,17,opt,name=granularity,def=100" json:"granularity,omitempty"`
	// Offset value between the output coordinates coordinates and the granularity grid in unites of nanodegrees.
	LatOffset *int64 `protobuf:"varint,19,opt,name=lat_offset,def=0" json:"lat_offset,omitempty"`
	LonOffset *int64 `protobuf:"varint,20,opt,name=lon_offset,def=0" json:"lon_offset,omitempty"`
	// Granularity of dates, normally represented in units of milliseconds since the 1970 epoch.
	DateGranularity *int32 `protobuf:"varint,18,opt,name=date_granularity,def=1000" json:"date_granularity,omitempty"`
}

func (m *PrimitiveBlock) Reset()         { *m = PrimitiveBlock{} }
func (m *PrimitiveBlock) String() string { return proto.CompactTextString(m) }
func (*PrimitiveBlock) ProtoMessage()    {}

const Default_PrimitiveBlock_Granularity int32 = 100
const Default_PrimitiveBlock_LatOffset int64 = 0
const Default_PrimitiveBlock_LonOffset int64 = 0
const Default_PrimitiveBlock_DateGranularity int32 = 1000

func (m *PrimitiveBlock) GetPrimitivegroup() []PrimitiveGroup {
	if m != nil {
		return m.Primitivegroup
	}
	return nil
}

func (m *PrimitiveBlock) GetGranularity() int32 {
	if m != nil && m.Granularity != nil {
		return *m.Granularity
	}
	return Default_PrimitiveBlock_Granularity
}

func (m *PrimitiveBlock) GetLatOffset() int64 {
	if m != nil && m.LatOffset != nil {
		return *m.LatOffset
	}
	return Default_PrimitiveBlock_LatOffset
}

func (m *PrimitiveBlock) GetLonOffset() int64 {
	if m != nil && m.LonOffset != nil {
		return *m.LonOffset
	}
	return Default_PrimitiveBlock_LonOffset
}

func (m *PrimitiveBlock) GetDateGranularity() int32 {
	if m != nil && m.DateGranularity != nil {
		return *m.DateGranularity
	}
	return Default_PrimitiveBlock_DateGranularity
}

// Group of OSMPrimitives. All primitives in a group must be the same type.
type PrimitiveGroup struct {
	Nodes      []Node      `protobuf:"bytes,1,rep,name=nodes" json:"nodes"`
	Dense      DenseNodes  `protobuf:"bytes,2,opt,name=dense" json:"dense"`
	Ways       []Way       `protobuf:"bytes,3,rep,name=ways" json:"ways"`
	Relations  []Relation  `protobuf:"bytes,4,rep,name=relations" json:"relations"`
	Changesets []ChangeSet `protobuf:"bytes,5,rep,name=changesets" json:"changesets"`
}

func (m *PrimitiveGroup) Reset()         { *m = PrimitiveGroup{} }
func (m *PrimitiveGroup) String() string { return proto.CompactTextString(m) }
func (*PrimitiveGroup) ProtoMessage()    {}

func (m *PrimitiveGroup) GetNodes() []Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *PrimitiveGroup) GetDense() DenseNodes {
	if m != nil {
		return m.Dense
	}
	return DenseNodes{}
}

func (m *PrimitiveGroup) GetWays() []Way {
	if m != nil {
		return m.Ways
	}
	return nil
}

func (m *PrimitiveGroup) GetRelations() []Relation {
	if m != nil {
		return m.Relations
	}
	return nil
}

func (m *PrimitiveGroup) GetChangesets() []ChangeSet {
	if m != nil {
		return m.Changesets
	}
	return nil
}

// * String table, contains the common strings in each block.
//
// Note that we reserve index '0' as a delimiter, so the entry at that
// index in the table is ALWAYS blank and unused.
//
type StringTable struct {
	Strings [][]byte `protobuf:"bytes,1,rep,name=s" json:"s,omitempty"`
}

func (m *StringTable) Reset()         { *m = StringTable{} }
func (m *StringTable) String() string { return proto.CompactTextString(m) }
func (*StringTable) ProtoMessage()    {}

func (m *StringTable) GetStrings() [][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

// Optional metadata that may be included into each primitive.
type Info struct {
	Version   int32  `protobuf:"varint,1,opt,name=version" json:"version"`
	Timestamp int64  `protobuf:"varint,2,opt,name=timestamp" json:"timestamp"`
	Changeset int64  `protobuf:"varint,3,opt,name=changeset" json:"changeset"`
	Uid       int32  `protobuf:"varint,4,opt,name=uid" json:"uid"`
	UserSid   uint32 `protobuf:"varint,5,opt,name=user_sid" json:"user_sid"`
	// The visible flag is used to store history information. It indicates that
	// the current object version has been created by a delete operation on the
	// OSM API.
	// When a writer sets this flag, it MUST add a required_features tag with
	// value "HistoricalInformation" to the HeaderBlock.
	// If this flag is not available for some object it MUST be assumed to be
	// true if the file has the required_features tag "HistoricalInformation"
	// set.
	Visible bool `protobuf:"varint,6,opt,name=visible" json:"visible"`
}

func (m *Info) Reset()         { *m = Info{} }
func (m *Info) String() string { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()    {}

func (m *Info) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Info) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Info) GetChangeset() int64 {
	if m != nil {
		return m.Changeset
	}
	return 0
}

func (m *Info) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Info) GetUserSid() uint32 {
	if m != nil {
		return m.UserSid
	}
	return 0
}

func (m *Info) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

// * Optional metadata that may be included into each primitive. Special dense format used in DenseNodes.
type DenseInfo struct {
	Version   []int32 `protobuf:"varint,1,rep,packed,name=version" json:"version,omitempty"`
	Timestamp []int64 `protobuf:"zigzag64,2,rep,packed,name=timestamp" json:"timestamp,omitempty"`
	Changeset []int64 `protobuf:"zigzag64,3,rep,packed,name=changeset" json:"changeset,omitempty"`
	Uid       []int32 `protobuf:"zigzag32,4,rep,packed,name=uid" json:"uid,omitempty"`
	UserSid   []int32 `protobuf:"zigzag32,5,rep,packed,name=user_sid" json:"user_sid,omitempty"`
	// The visible flag is used to store history information. It indicates that
	// the current object version has been created by a delete operation on the
	// OSM API.
	// When a writer sets this flag, it MUST add a required_features tag with
	// value "HistoricalInformation" to the HeaderBlock.
	// If this flag is not available for some object it MUST be assumed to be
	// true if the file has the required_features tag "HistoricalInformation"
	// set.
	Visible []bool `protobuf:"varint,6,rep,packed,name=visible" json:"visible,omitempty"`
}

func (m *DenseInfo) Reset()         { *m = DenseInfo{} }
func (m *DenseInfo) String() string { return proto.CompactTextString(m) }
func (*DenseInfo) ProtoMessage()    {}

func (m *DenseInfo) GetVersion() []int32 {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *DenseInfo) GetTimestamp() []int64 {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *DenseInfo) GetChangeset() []int64 {
	if m != nil {
		return m.Changeset
	}
	return nil
}

func (m *DenseInfo) GetUid() []int32 {
	if m != nil {
		return m.Uid
	}
	return nil
}

func (m *DenseInfo) GetUserSid() []int32 {
	if m != nil {
		return m.UserSid
	}
	return nil
}

func (m *DenseInfo) GetVisible() []bool {
	if m != nil {
		return m.Visible
	}
	return nil
}

// THIS IS STUB DESIGN FOR CHANGESETS. NOT USED RIGHT NOW.
// TODO:    REMOVE THIS?
type ChangeSet struct {
	Id *int64 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
}

func (m *ChangeSet) Reset()         { *m = ChangeSet{} }
func (m *ChangeSet) String() string { return proto.CompactTextString(m) }
func (*ChangeSet) ProtoMessage()    {}

func (m *ChangeSet) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

type Node struct {
	Id int64 `protobuf:"zigzag64,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	Lat  int64    `protobuf:"zigzag64,8,req,name=lat" json:"lat"`
	Lon  int64    `protobuf:"zigzag64,9,req,name=lon" json:"lon"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}

func (m *Node) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Node) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Node) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Node) GetLat() int64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *Node) GetLon() int64 {
	if m != nil {
		return m.Lon
	}
	return 0
}

type DenseNodes struct {
	Id []int64 `protobuf:"zigzag64,1,rep,packed,name=id" json:"id,omitempty"`
	// repeated Info info = 4;
	Denseinfo DenseInfo `protobuf:"bytes,5,opt,name=denseinfo" json:"denseinfo"`
	Lat       []int64   `protobuf:"zigzag64,8,rep,packed,name=lat" json:"lat,omitempty"`
	Lon       []int64   `protobuf:"zigzag64,9,rep,packed,name=lon" json:"lon,omitempty"`
	// Special packing of keys and vals into one array. May be empty if all nodes in this block are tagless.
	KeysVals []int32 `protobuf:"varint,10,rep,packed,name=keys_vals" json:"keys_vals,omitempty"`
}

func (m *DenseNodes) Reset()         { *m = DenseNodes{} }
func (m *DenseNodes) String() string { return proto.CompactTextString(m) }
func (*DenseNodes) ProtoMessage()    {}

func (m *DenseNodes) GetId() []int64 {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DenseNodes) GetDenseinfo() DenseInfo {
	if m != nil {
		return m.Denseinfo
	}
	return DenseInfo{}
}

func (m *DenseNodes) GetLat() []int64 {
	if m != nil {
		return m.Lat
	}
	return nil
}

func (m *DenseNodes) GetLon() []int64 {
	if m != nil {
		return m.Lon
	}
	return nil
}

func (m *DenseNodes) GetKeysVals() []int32 {
	if m != nil {
		return m.KeysVals
	}
	return nil
}

type Way struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	Refs []int64  `protobuf:"zigzag64,8,rep,packed,name=refs" json:"refs,omitempty"`
}

func (m *Way) Reset()         { *m = Way{} }
func (m *Way) String() string { return proto.CompactTextString(m) }
func (*Way) ProtoMessage()    {}

func (m *Way) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Way) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Way) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Way) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Way) GetRefs() []int64 {
	if m != nil {
		return m.Refs
	}
	return nil
}

type Relation struct {
	Id *int64 `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	// Parallel arrays
	RolesSid []int32               `protobuf:"varint,8,rep,packed,name=roles_sid" json:"roles_sid,omitempty"`
	Memids   []int64               `protobuf:"zigzag64,9,rep,packed,name=memids" json:"memids,omitempty"`
	Types    []Relation_MemberType `protobuf:"varint,10,rep,packed,name=types,enum=OSMPBF.Relation_MemberType" json:"types,omitempty"`
}

func (m *Relation) Reset()         { *m = Relation{} }
func (m *Relation) String() string { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()    {}

func (m *Relation) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Relation) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Relation) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Relation) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Relation) GetRolesSid() []int32 {
	if m != nil {
		return m.RolesSid
	}
	return nil
}

func (m *Relation) GetMemids() []int64 {
	if m != nil {
		return m.Memids
	}
	return nil
}

func (m *Relation) GetTypes() []Relation_MemberType {
	if m != nil {
		return m.Types
	}
	return nil
}

func init() {
	proto.RegisterType((*HeaderBlock)(nil), "OSMPBF.HeaderBlock")
	proto.RegisterType((*HeaderBBox)(nil), "OSMPBF.HeaderBBox")
	proto.RegisterType((*PrimitiveBlock)(nil), "OSMPBF.PrimitiveBlock")
	proto.RegisterType((*PrimitiveGroup)(nil), "OSMPBF.PrimitiveGroup")
	proto.RegisterType((*StringTable)(nil), "OSMPBF.StringTable")
	proto.RegisterType((*Info)(nil), "OSMPBF.Info")
	proto.RegisterType((*DenseInfo)(nil), "OSMPBF.DenseInfo")
	proto.RegisterType((*ChangeSet)(nil), "OSMPBF.ChangeSet")
	proto.RegisterType((*Node)(nil), "OSMPBF.Node")
	proto.RegisterType((*DenseNodes)(nil), "OSMPBF.DenseNodes")
	proto.RegisterType((*Way)(nil), "OSMPBF.Way")
	proto.RegisterType((*Relation)(nil), "OSMPBF.Relation")
	proto.RegisterEnum("OSMPBF.Relation_MemberType", Relation_MemberType_name, Relation_MemberType_value)
}
func (this *HeaderBlock) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HeaderBlock)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Bbox.Equal(that1.Bbox) {
		return false
	}
	if len(this.RequiredFeatures) != len(that1.RequiredFeatures) {
		return false
	}
	for i := range this.RequiredFeatures {
		if this.RequiredFeatures[i] != that1.RequiredFeatures[i] {
			return false
		}
	}
	if len(this.OptionalFeatures) != len(that1.OptionalFeatures) {
		return false
	}
	for i := range this.OptionalFeatures {
		if this.OptionalFeatures[i] != that1.OptionalFeatures[i] {
			return false
		}
	}
	if this.Writingprogram != nil && that1.Writingprogram != nil {
		if *this.Writingprogram != *that1.Writingprogram {
			return false
		}
	} else if this.Writingprogram != nil {
		return false
	} else if that1.Writingprogram != nil {
		return false
	}
	if this.Source != nil && that1.Source != nil {
		if *this.Source != *that1.Source {
			return false
		}
	} else if this.Source != nil {
		return false
	} else if that1.Source != nil {
		return false
	}
	if this.OsmosisReplicationTimestamp != nil && that1.OsmosisReplicationTimestamp != nil {
		if *this.OsmosisReplicationTimestamp != *that1.OsmosisReplicationTimestamp {
			return false
		}
	} else if this.OsmosisReplicationTimestamp != nil {
		return false
	} else if that1.OsmosisReplicationTimestamp != nil {
		return false
	}
	if this.OsmosisReplicationSequenceNumber != nil && that1.OsmosisReplicationSequenceNumber != nil {
		if *this.OsmosisReplicationSequenceNumber != *that1.OsmosisReplicationSequenceNumber {
			return false
		}
	} else if this.OsmosisReplicationSequenceNumber != nil {
		return false
	} else if that1.OsmosisReplicationSequenceNumber != nil {
		return false
	}
	if this.OsmosisReplicationBaseUrl != nil && that1.OsmosisReplicationBaseUrl != nil {
		if *this.OsmosisReplicationBaseUrl != *that1.OsmosisReplicationBaseUrl {
			return false
		}
	} else if this.OsmosisReplicationBaseUrl != nil {
		return false
	} else if that1.OsmosisReplicationBaseUrl != nil {
		return false
	}
	return true
}
func (this *HeaderBBox) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HeaderBBox)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Left != that1.Left {
		return false
	}
	if this.Right != that1.Right {
		return false
	}
	if this.Top != that1.Top {
		return false
	}
	if this.Bottom != that1.Bottom {
		return false
	}
	return true
}
func (this *PrimitiveBlock) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PrimitiveBlock)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.StringTable.Equal(&that1.StringTable) {
		return false
	}
	if len(this.Primitivegroup) != len(that1.Primitivegroup) {
		return false
	}
	for i := range this.Primitivegroup {
		if !this.Primitivegroup[i].Equal(&that1.Primitivegroup[i]) {
			return false
		}
	}
	if this.Granularity != nil && that1.Granularity != nil {
		if *this.Granularity != *that1.Granularity {
			return false
		}
	} else if this.Granularity != nil {
		return false
	} else if that1.Granularity != nil {
		return false
	}
	if this.LatOffset != nil && that1.LatOffset != nil {
		if *this.LatOffset != *that1.LatOffset {
			return false
		}
	} else if this.LatOffset != nil {
		return false
	} else if that1.LatOffset != nil {
		return false
	}
	if this.LonOffset != nil && that1.LonOffset != nil {
		if *this.LonOffset != *that1.LonOffset {
			return false
		}
	} else if this.LonOffset != nil {
		return false
	} else if that1.LonOffset != nil {
		return false
	}
	if this.DateGranularity != nil && that1.DateGranularity != nil {
		if *this.DateGranularity != *that1.DateGranularity {
			return false
		}
	} else if this.DateGranularity != nil {
		return false
	} else if that1.DateGranularity != nil {
		return false
	}
	return true
}
func (this *PrimitiveGroup) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PrimitiveGroup)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(&that1.Nodes[i]) {
			return false
		}
	}
	if !this.Dense.Equal(&that1.Dense) {
		return false
	}
	if len(this.Ways) != len(that1.Ways) {
		return false
	}
	for i := range this.Ways {
		if !this.Ways[i].Equal(&that1.Ways[i]) {
			return false
		}
	}
	if len(this.Relations) != len(that1.Relations) {
		return false
	}
	for i := range this.Relations {
		if !this.Relations[i].Equal(&that1.Relations[i]) {
			return false
		}
	}
	if len(this.Changesets) != len(that1.Changesets) {
		return false
	}
	for i := range this.Changesets {
		if !this.Changesets[i].Equal(&that1.Changesets[i]) {
			return false
		}
	}
	return true
}
func (this *StringTable) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StringTable)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Strings) != len(that1.Strings) {
		return false
	}
	for i := range this.Strings {
		if !bytes.Equal(this.Strings[i], that1.Strings[i]) {
			return false
		}
	}
	return true
}
func (this *Info) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Info)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Changeset != that1.Changeset {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.UserSid != that1.UserSid {
		return false
	}
	if this.Visible != that1.Visible {
		return false
	}
	return true
}
func (this *DenseInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DenseInfo)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Version) != len(that1.Version) {
		return false
	}
	for i := range this.Version {
		if this.Version[i] != that1.Version[i] {
			return false
		}
	}
	if len(this.Timestamp) != len(that1.Timestamp) {
		return false
	}
	for i := range this.Timestamp {
		if this.Timestamp[i] != that1.Timestamp[i] {
			return false
		}
	}
	if len(this.Changeset) != len(that1.Changeset) {
		return false
	}
	for i := range this.Changeset {
		if this.Changeset[i] != that1.Changeset[i] {
			return false
		}
	}
	if len(this.Uid) != len(that1.Uid) {
		return false
	}
	for i := range this.Uid {
		if this.Uid[i] != that1.Uid[i] {
			return false
		}
	}
	if len(this.UserSid) != len(that1.UserSid) {
		return false
	}
	for i := range this.UserSid {
		if this.UserSid[i] != that1.UserSid[i] {
			return false
		}
	}
	if len(this.Visible) != len(that1.Visible) {
		return false
	}
	for i := range this.Visible {
		if this.Visible[i] != that1.Visible[i] {
			return false
		}
	}
	return true
}
func (this *ChangeSet) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ChangeSet)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != nil && that1.Id != nil {
		if *this.Id != *that1.Id {
			return false
		}
	} else if this.Id != nil {
		return false
	} else if that1.Id != nil {
		return false
	}
	return true
}
func (this *Node) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Node)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if len(this.Vals) != len(that1.Vals) {
		return false
	}
	for i := range this.Vals {
		if this.Vals[i] != that1.Vals[i] {
			return false
		}
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if this.Lat != that1.Lat {
		return false
	}
	if this.Lon != that1.Lon {
		return false
	}
	return true
}
func (this *DenseNodes) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DenseNodes)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Id) != len(that1.Id) {
		return false
	}
	for i := range this.Id {
		if this.Id[i] != that1.Id[i] {
			return false
		}
	}
	if !this.Denseinfo.Equal(&that1.Denseinfo) {
		return false
	}
	if len(this.Lat) != len(that1.Lat) {
		return false
	}
	for i := range this.Lat {
		if this.Lat[i] != that1.Lat[i] {
			return false
		}
	}
	if len(this.Lon) != len(that1.Lon) {
		return false
	}
	for i := range this.Lon {
		if this.Lon[i] != that1.Lon[i] {
			return false
		}
	}
	if len(this.KeysVals) != len(that1.KeysVals) {
		return false
	}
	for i := range this.KeysVals {
		if this.KeysVals[i] != that1.KeysVals[i] {
			return false
		}
	}
	return true
}
func (this *Way) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Way)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if len(this.Vals) != len(that1.Vals) {
		return false
	}
	for i := range this.Vals {
		if this.Vals[i] != that1.Vals[i] {
			return false
		}
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Refs) != len(that1.Refs) {
		return false
	}
	for i := range this.Refs {
		if this.Refs[i] != that1.Refs[i] {
			return false
		}
	}
	return true
}
func (this *Relation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Relation)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != nil && that1.Id != nil {
		if *this.Id != *that1.Id {
			return false
		}
	} else if this.Id != nil {
		return false
	} else if that1.Id != nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if len(this.Vals) != len(that1.Vals) {
		return false
	}
	for i := range this.Vals {
		if this.Vals[i] != that1.Vals[i] {
			return false
		}
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.RolesSid) != len(that1.RolesSid) {
		return false
	}
	for i := range this.RolesSid {
		if this.RolesSid[i] != that1.RolesSid[i] {
			return false
		}
	}
	if len(this.Memids) != len(that1.Memids) {
		return false
	}
	for i := range this.Memids {
		if this.Memids[i] != that1.Memids[i] {
			return false
		}
	}
	if len(this.Types) != len(that1.Types) {
		return false
	}
	for i := range this.Types {
		if this.Types[i] != that1.Types[i] {
			return false
		}
	}
	return true
}
func (this *HeaderBlock) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&OSMPBF.HeaderBlock{")
	if this.Bbox != nil {
		s = append(s, "Bbox: "+fmt.Sprintf("%#v", this.Bbox)+",\n")
	}
	if this.RequiredFeatures != nil {
		s = append(s, "RequiredFeatures: "+fmt.Sprintf("%#v", this.RequiredFeatures)+",\n")
	}
	if this.OptionalFeatures != nil {
		s = append(s, "OptionalFeatures: "+fmt.Sprintf("%#v", this.OptionalFeatures)+",\n")
	}
	if this.Writingprogram != nil {
		s = append(s, "Writingprogram: "+valueToGoStringOsmformat(this.Writingprogram, "string")+",\n")
	}
	if this.Source != nil {
		s = append(s, "Source: "+valueToGoStringOsmformat(this.Source, "string")+",\n")
	}
	if this.OsmosisReplicationTimestamp != nil {
		s = append(s, "OsmosisReplicationTimestamp: "+valueToGoStringOsmformat(this.OsmosisReplicationTimestamp, "int64")+",\n")
	}
	if this.OsmosisReplicationSequenceNumber != nil {
		s = append(s, "OsmosisReplicationSequenceNumber: "+valueToGoStringOsmformat(this.OsmosisReplicationSequenceNumber, "int64")+",\n")
	}
	if this.OsmosisReplicationBaseUrl != nil {
		s = append(s, "OsmosisReplicationBaseUrl: "+valueToGoStringOsmformat(this.OsmosisReplicationBaseUrl, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderBBox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&OSMPBF.HeaderBBox{")
	s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	s = append(s, "Top: "+fmt.Sprintf("%#v", this.Top)+",\n")
	s = append(s, "Bottom: "+fmt.Sprintf("%#v", this.Bottom)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PrimitiveBlock) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&OSMPBF.PrimitiveBlock{")
	s = append(s, "StringTable: "+strings.Replace(this.StringTable.GoString(), `&`, ``, 1)+",\n")
	if this.Primitivegroup != nil {
		s = append(s, "Primitivegroup: "+strings.Replace(fmt.Sprintf("%#v", this.Primitivegroup), `&`, ``, 1)+",\n")
	}
	if this.Granularity != nil {
		s = append(s, "Granularity: "+valueToGoStringOsmformat(this.Granularity, "int32")+",\n")
	}
	if this.LatOffset != nil {
		s = append(s, "LatOffset: "+valueToGoStringOsmformat(this.LatOffset, "int64")+",\n")
	}
	if this.LonOffset != nil {
		s = append(s, "LonOffset: "+valueToGoStringOsmformat(this.LonOffset, "int64")+",\n")
	}
	if this.DateGranularity != nil {
		s = append(s, "DateGranularity: "+valueToGoStringOsmformat(this.DateGranularity, "int32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PrimitiveGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&OSMPBF.PrimitiveGroup{")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+strings.Replace(fmt.Sprintf("%#v", this.Nodes), `&`, ``, 1)+",\n")
	}
	s = append(s, "Dense: "+strings.Replace(this.Dense.GoString(), `&`, ``, 1)+",\n")
	if this.Ways != nil {
		s = append(s, "Ways: "+strings.Replace(fmt.Sprintf("%#v", this.Ways), `&`, ``, 1)+",\n")
	}
	if this.Relations != nil {
		s = append(s, "Relations: "+strings.Replace(fmt.Sprintf("%#v", this.Relations), `&`, ``, 1)+",\n")
	}
	if this.Changesets != nil {
		s = append(s, "Changesets: "+strings.Replace(fmt.Sprintf("%#v", this.Changesets), `&`, ``, 1)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StringTable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&OSMPBF.StringTable{")
	if this.Strings != nil {
		s = append(s, "Strings: "+fmt.Sprintf("%#v", this.Strings)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Info) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&OSMPBF.Info{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Changeset: "+fmt.Sprintf("%#v", this.Changeset)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "UserSid: "+fmt.Sprintf("%#v", this.UserSid)+",\n")
	s = append(s, "Visible: "+fmt.Sprintf("%#v", this.Visible)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DenseInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&OSMPBF.DenseInfo{")
	if this.Version != nil {
		s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	}
	if this.Timestamp != nil {
		s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	}
	if this.Changeset != nil {
		s = append(s, "Changeset: "+fmt.Sprintf("%#v", this.Changeset)+",\n")
	}
	if this.Uid != nil {
		s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	}
	if this.UserSid != nil {
		s = append(s, "UserSid: "+fmt.Sprintf("%#v", this.UserSid)+",\n")
	}
	if this.Visible != nil {
		s = append(s, "Visible: "+fmt.Sprintf("%#v", this.Visible)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChangeSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&OSMPBF.ChangeSet{")
	if this.Id != nil {
		s = append(s, "Id: "+valueToGoStringOsmformat(this.Id, "int64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&OSMPBF.Node{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Keys != nil {
		s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	}
	if this.Vals != nil {
		s = append(s, "Vals: "+fmt.Sprintf("%#v", this.Vals)+",\n")
	}
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "Lat: "+fmt.Sprintf("%#v", this.Lat)+",\n")
	s = append(s, "Lon: "+fmt.Sprintf("%#v", this.Lon)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DenseNodes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&OSMPBF.DenseNodes{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	s = append(s, "Denseinfo: "+strings.Replace(this.Denseinfo.GoString(), `&`, ``, 1)+",\n")
	if this.Lat != nil {
		s = append(s, "Lat: "+fmt.Sprintf("%#v", this.Lat)+",\n")
	}
	if this.Lon != nil {
		s = append(s, "Lon: "+fmt.Sprintf("%#v", this.Lon)+",\n")
	}
	if this.KeysVals != nil {
		s = append(s, "KeysVals: "+fmt.Sprintf("%#v", this.KeysVals)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Way) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&OSMPBF.Way{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Keys != nil {
		s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	}
	if this.Vals != nil {
		s = append(s, "Vals: "+fmt.Sprintf("%#v", this.Vals)+",\n")
	}
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Refs != nil {
		s = append(s, "Refs: "+fmt.Sprintf("%#v", this.Refs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Relation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&OSMPBF.Relation{")
	if this.Id != nil {
		s = append(s, "Id: "+valueToGoStringOsmformat(this.Id, "int64")+",\n")
	}
	if this.Keys != nil {
		s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	}
	if this.Vals != nil {
		s = append(s, "Vals: "+fmt.Sprintf("%#v", this.Vals)+",\n")
	}
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.RolesSid != nil {
		s = append(s, "RolesSid: "+fmt.Sprintf("%#v", this.RolesSid)+",\n")
	}
	if this.Memids != nil {
		s = append(s, "Memids: "+fmt.Sprintf("%#v", this.Memids)+",\n")
	}
	if this.Types != nil {
		s = append(s, "Types: "+fmt.Sprintf("%#v", this.Types)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringOsmformat(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringOsmformat(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (m *HeaderBlock) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HeaderBlock) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bbox != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOsmformat(data, i, uint64(m.Bbox.Size()))
		n1, err := m.Bbox.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.RequiredFeatures) > 0 {
		for _, s := range m.RequiredFeatures {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.OptionalFeatures) > 0 {
		for _, s := range m.OptionalFeatures {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Writingprogram != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOsmformat(data, i, uint64(len(*m.Writingprogram)))
		i += copy(data[i:], *m.Writingprogram)
	}
	if m.Source != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOsmformat(data, i, uint64(len(*m.Source)))
		i += copy(data[i:], *m.Source)
	}
	if m.OsmosisReplicationTimestamp != nil {
		data[i] = 0x80
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOsmformat(data, i, uint64(*m.OsmosisReplicationTimestamp))
	}
	if m.OsmosisReplicationSequenceNumber != nil {
		data[i] = 0x88
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOsmformat(data, i, uint64(*m.OsmosisReplicationSequenceNumber))
	}
	if m.OsmosisReplicationBaseUrl != nil {
		data[i] = 0x92
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOsmformat(data, i, uint64(len(*m.OsmosisReplicationBaseUrl)))
		i += copy(data[i:], *m.OsmosisReplicationBaseUrl)
	}
	return i, nil
}

func (m *HeaderBBox) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HeaderBBox) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsmformat(data, i, uint64((uint64(m.Left)<<1)^uint64((m.Left>>63))))
	data[i] = 0x10
	i++
	i = encodeVarintOsmformat(data, i, uint64((uint64(m.Right)<<1)^uint64((m.Right>>63))))
	data[i] = 0x18
	i++
	i = encodeVarintOsmformat(data, i, uint64((uint64(m.Top)<<1)^uint64((m.Top>>63))))
	data[i] = 0x20
	i++
	i = encodeVarintOsmformat(data, i, uint64((uint64(m.Bottom)<<1)^uint64((m.Bottom>>63))))
	return i, nil
}

func (m *PrimitiveBlock) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PrimitiveBlock) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.StringTable.Size()))
	n2, err := m.StringTable.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.Primitivegroup) > 0 {
		for _, msg := range m.Primitivegroup {
			data[i] = 0x12
			i++
			i = encodeVarintOsmformat(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Granularity != nil {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOsmformat(data, i, uint64(*m.Granularity))
	}
	if m.DateGranularity != nil {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOsmformat(data, i, uint64(*m.DateGranularity))
	}
	if m.LatOffset != nil {
		data[i] = 0x98
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOsmformat(data, i, uint64(*m.LatOffset))
	}
	if m.LonOffset != nil {
		data[i] = 0xa0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOsmformat(data, i, uint64(*m.LonOffset))
	}
	return i, nil
}

func (m *PrimitiveGroup) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PrimitiveGroup) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			data[i] = 0xa
			i++
			i = encodeVarintOsmformat(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.Dense.Size()))
	n3, err := m.Dense.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.Ways) > 0 {
		for _, msg := range m.Ways {
			data[i] = 0x1a
			i++
			i = encodeVarintOsmformat(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Relations) > 0 {
		for _, msg := range m.Relations {
			data[i] = 0x22
			i++
			i = encodeVarintOsmformat(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Changesets) > 0 {
		for _, msg := range m.Changesets {
			data[i] = 0x2a
			i++
			i = encodeVarintOsmformat(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StringTable) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StringTable) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for _, b := range m.Strings {
			data[i] = 0xa
			i++
			i = encodeVarintOsmformat(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	return i, nil
}

func (m *Info) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Info) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.Version))
	data[i] = 0x10
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.Timestamp))
	data[i] = 0x18
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.Changeset))
	data[i] = 0x20
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.Uid))
	data[i] = 0x28
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.UserSid))
	data[i] = 0x30
	i++
	if m.Visible {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	return i, nil
}

func (m *DenseInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DenseInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		data5 := make([]byte, len(m.Version)*10)
		var j4 int
		for _, num1 := range m.Version {
			num := uint64(num1)
			for num >= 1<<7 {
				data5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			data5[j4] = uint8(num)
			j4++
		}
		data[i] = 0xa
		i++
		i = encodeVarintOsmformat(data, i, uint64(j4))
		i += copy(data[i:], data5[:j4])
	}
	if len(m.Timestamp) > 0 {
		var j6 int
		data8 := make([]byte, len(m.Timestamp)*10)
		for _, num := range m.Timestamp {
			x7 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x7 >= 1<<7 {
				data8[j6] = uint8(uint64(x7)&0x7f | 0x80)
				j6++
				x7 >>= 7
			}
			data8[j6] = uint8(x7)
			j6++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsmformat(data, i, uint64(j6))
		i += copy(data[i:], data8[:j6])
	}
	if len(m.Changeset) > 0 {
		var j9 int
		data11 := make([]byte, len(m.Changeset)*10)
		for _, num := range m.Changeset {
			x10 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x10 >= 1<<7 {
				data11[j9] = uint8(uint64(x10)&0x7f | 0x80)
				j9++
				x10 >>= 7
			}
			data11[j9] = uint8(x10)
			j9++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsmformat(data, i, uint64(j9))
		i += copy(data[i:], data11[:j9])
	}
	if len(m.Uid) > 0 {
		data12 := make([]byte, len(m.Uid)*5)
		var j13 int
		for _, num := range m.Uid {
			x14 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x14 >= 1<<7 {
				data12[j13] = uint8(uint64(x14)&0x7f | 0x80)
				j13++
				x14 >>= 7
			}
			data12[j13] = uint8(x14)
			j13++
		}
		data[i] = 0x22
		i++
		i = encodeVarintOsmformat(data, i, uint64(j13))
		i += copy(data[i:], data12[:j13])
	}
	if len(m.UserSid) > 0 {
		data15 := make([]byte, len(m.UserSid)*5)
		var j16 int
		for _, num := range m.UserSid {
			x17 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x17 >= 1<<7 {
				data15[j16] = uint8(uint64(x17)&0x7f | 0x80)
				j16++
				x17 >>= 7
			}
			data15[j16] = uint8(x17)
			j16++
		}
		data[i] = 0x2a
		i++
		i = encodeVarintOsmformat(data, i, uint64(j16))
		i += copy(data[i:], data15[:j16])
	}
	if len(m.Visible) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintOsmformat(data, i, uint64(len(m.Visible)))
		for _, b := range m.Visible {
			if b {
				data[i] = 1
			} else {
				data[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *ChangeSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangeSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	} else {
		data[i] = 0x8
		i++
		i = encodeVarintOsmformat(data, i, uint64(*m.Id))
	}
	return i, nil
}

func (m *Node) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Node) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsmformat(data, i, uint64((uint64(m.Id)<<1)^uint64((m.Id>>63))))
	if len(m.Keys) > 0 {
		data19 := make([]byte, len(m.Keys)*10)
		var j18 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				data19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			data19[j18] = uint8(num)
			j18++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsmformat(data, i, uint64(j18))
		i += copy(data[i:], data19[:j18])
	}
	if len(m.Vals) > 0 {
		data21 := make([]byte, len(m.Vals)*10)
		var j20 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				data21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			data21[j20] = uint8(num)
			j20++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsmformat(data, i, uint64(j20))
		i += copy(data[i:], data21[:j20])
	}
	if m.Info != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOsmformat(data, i, uint64(m.Info.Size()))
		n22, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	data[i] = 0x40
	i++
	i = encodeVarintOsmformat(data, i, uint64((uint64(m.Lat)<<1)^uint64((m.Lat>>63))))
	data[i] = 0x48
	i++
	i = encodeVarintOsmformat(data, i, uint64((uint64(m.Lon)<<1)^uint64((m.Lon>>63))))
	return i, nil
}

func (m *DenseNodes) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DenseNodes) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		var j23 int
		data25 := make([]byte, len(m.Id)*10)
		for _, num := range m.Id {
			x24 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x24 >= 1<<7 {
				data25[j23] = uint8(uint64(x24)&0x7f | 0x80)
				j23++
				x24 >>= 7
			}
			data25[j23] = uint8(x24)
			j23++
		}
		data[i] = 0xa
		i++
		i = encodeVarintOsmformat(data, i, uint64(j23))
		i += copy(data[i:], data25[:j23])
	}
	data[i] = 0x2a
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.Denseinfo.Size()))
	n26, err := m.Denseinfo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	if len(m.Lat) > 0 {
		var j27 int
		data29 := make([]byte, len(m.Lat)*10)
		for _, num := range m.Lat {
			x28 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x28 >= 1<<7 {
				data29[j27] = uint8(uint64(x28)&0x7f | 0x80)
				j27++
				x28 >>= 7
			}
			data29[j27] = uint8(x28)
			j27++
		}
		data[i] = 0x42
		i++
		i = encodeVarintOsmformat(data, i, uint64(j27))
		i += copy(data[i:], data29[:j27])
	}
	if len(m.Lon) > 0 {
		var j30 int
		data32 := make([]byte, len(m.Lon)*10)
		for _, num := range m.Lon {
			x31 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x31 >= 1<<7 {
				data32[j30] = uint8(uint64(x31)&0x7f | 0x80)
				j30++
				x31 >>= 7
			}
			data32[j30] = uint8(x31)
			j30++
		}
		data[i] = 0x4a
		i++
		i = encodeVarintOsmformat(data, i, uint64(j30))
		i += copy(data[i:], data32[:j30])
	}
	if len(m.KeysVals) > 0 {
		data34 := make([]byte, len(m.KeysVals)*10)
		var j33 int
		for _, num1 := range m.KeysVals {
			num := uint64(num1)
			for num >= 1<<7 {
				data34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			data34[j33] = uint8(num)
			j33++
		}
		data[i] = 0x52
		i++
		i = encodeVarintOsmformat(data, i, uint64(j33))
		i += copy(data[i:], data34[:j33])
	}
	return i, nil
}

func (m *Way) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Way) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOsmformat(data, i, uint64(m.Id))
	if len(m.Keys) > 0 {
		data36 := make([]byte, len(m.Keys)*10)
		var j35 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				data36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			data36[j35] = uint8(num)
			j35++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsmformat(data, i, uint64(j35))
		i += copy(data[i:], data36[:j35])
	}
	if len(m.Vals) > 0 {
		data38 := make([]byte, len(m.Vals)*10)
		var j37 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				data38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			data38[j37] = uint8(num)
			j37++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsmformat(data, i, uint64(j37))
		i += copy(data[i:], data38[:j37])
	}
	if m.Info != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOsmformat(data, i, uint64(m.Info.Size()))
		n39, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Refs) > 0 {
		var j40 int
		data42 := make([]byte, len(m.Refs)*10)
		for _, num := range m.Refs {
			x41 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x41 >= 1<<7 {
				data42[j40] = uint8(uint64(x41)&0x7f | 0x80)
				j40++
				x41 >>= 7
			}
			data42[j40] = uint8(x41)
			j40++
		}
		data[i] = 0x42
		i++
		i = encodeVarintOsmformat(data, i, uint64(j40))
		i += copy(data[i:], data42[:j40])
	}
	return i, nil
}

func (m *Relation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Relation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	} else {
		data[i] = 0x8
		i++
		i = encodeVarintOsmformat(data, i, uint64(*m.Id))
	}
	if len(m.Keys) > 0 {
		data44 := make([]byte, len(m.Keys)*10)
		var j43 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				data44[j43] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j43++
			}
			data44[j43] = uint8(num)
			j43++
		}
		data[i] = 0x12
		i++
		i = encodeVarintOsmformat(data, i, uint64(j43))
		i += copy(data[i:], data44[:j43])
	}
	if len(m.Vals) > 0 {
		data46 := make([]byte, len(m.Vals)*10)
		var j45 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				data46[j45] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j45++
			}
			data46[j45] = uint8(num)
			j45++
		}
		data[i] = 0x1a
		i++
		i = encodeVarintOsmformat(data, i, uint64(j45))
		i += copy(data[i:], data46[:j45])
	}
	if m.Info != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOsmformat(data, i, uint64(m.Info.Size()))
		n47, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.RolesSid) > 0 {
		data49 := make([]byte, len(m.RolesSid)*10)
		var j48 int
		for _, num1 := range m.RolesSid {
			num := uint64(num1)
			for num >= 1<<7 {
				data49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			data49[j48] = uint8(num)
			j48++
		}
		data[i] = 0x42
		i++
		i = encodeVarintOsmformat(data, i, uint64(j48))
		i += copy(data[i:], data49[:j48])
	}
	if len(m.Memids) > 0 {
		var j50 int
		data52 := make([]byte, len(m.Memids)*10)
		for _, num := range m.Memids {
			x51 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x51 >= 1<<7 {
				data52[j50] = uint8(uint64(x51)&0x7f | 0x80)
				j50++
				x51 >>= 7
			}
			data52[j50] = uint8(x51)
			j50++
		}
		data[i] = 0x4a
		i++
		i = encodeVarintOsmformat(data, i, uint64(j50))
		i += copy(data[i:], data52[:j50])
	}
	if len(m.Types) > 0 {
		data54 := make([]byte, len(m.Types)*10)
		var j53 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				data54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			data54[j53] = uint8(num)
			j53++
		}
		data[i] = 0x52
		i++
		i = encodeVarintOsmformat(data, i, uint64(j53))
		i += copy(data[i:], data54[:j53])
	}
	return i, nil
}

func encodeFixed64Osmformat(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Osmformat(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintOsmformat(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *HeaderBlock) Size() (n int) {
	var l int
	_ = l
	if m.Bbox != nil {
		l = m.Bbox.Size()
		n += 1 + l + sovOsmformat(uint64(l))
	}
	if len(m.RequiredFeatures) > 0 {
		for _, s := range m.RequiredFeatures {
			l = len(s)
			n += 1 + l + sovOsmformat(uint64(l))
		}
	}
	if len(m.OptionalFeatures) > 0 {
		for _, s := range m.OptionalFeatures {
			l = len(s)
			n += 1 + l + sovOsmformat(uint64(l))
		}
	}
	if m.Writingprogram != nil {
		l = len(*m.Writingprogram)
		n += 2 + l + sovOsmformat(uint64(l))
	}
	if m.Source != nil {
		l = len(*m.Source)
		n += 2 + l + sovOsmformat(uint64(l))
	}
	if m.OsmosisReplicationTimestamp != nil {
		n += 2 + sovOsmformat(uint64(*m.OsmosisReplicationTimestamp))
	}
	if m.OsmosisReplicationSequenceNumber != nil {
		n += 2 + sovOsmformat(uint64(*m.OsmosisReplicationSequenceNumber))
	}
	if m.OsmosisReplicationBaseUrl != nil {
		l = len(*m.OsmosisReplicationBaseUrl)
		n += 2 + l + sovOsmformat(uint64(l))
	}
	return n
}

func (m *HeaderBBox) Size() (n int) {
	var l int
	_ = l
	n += 1 + sozOsmformat(uint64(m.Left))
	n += 1 + sozOsmformat(uint64(m.Right))
	n += 1 + sozOsmformat(uint64(m.Top))
	n += 1 + sozOsmformat(uint64(m.Bottom))
	return n
}

func (m *PrimitiveBlock) Size() (n int) {
	var l int
	_ = l
	l = m.StringTable.Size()
	n += 1 + l + sovOsmformat(uint64(l))
	if len(m.Primitivegroup) > 0 {
		for _, e := range m.Primitivegroup {
			l = e.Size()
			n += 1 + l + sovOsmformat(uint64(l))
		}
	}
	if m.Granularity != nil {
		n += 2 + sovOsmformat(uint64(*m.Granularity))
	}
	if m.DateGranularity != nil {
		n += 2 + sovOsmformat(uint64(*m.DateGranularity))
	}
	if m.LatOffset != nil {
		n += 2 + sovOsmformat(uint64(*m.LatOffset))
	}
	if m.LonOffset != nil {
		n += 2 + sovOsmformat(uint64(*m.LonOffset))
	}
	return n
}

func (m *PrimitiveGroup) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovOsmformat(uint64(l))
		}
	}
	l = m.Dense.Size()
	n += 1 + l + sovOsmformat(uint64(l))
	if len(m.Ways) > 0 {
		for _, e := range m.Ways {
			l = e.Size()
			n += 1 + l + sovOsmformat(uint64(l))
		}
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovOsmformat(uint64(l))
		}
	}
	if len(m.Changesets) > 0 {
		for _, e := range m.Changesets {
			l = e.Size()
			n += 1 + l + sovOsmformat(uint64(l))
		}
	}
	return n
}

func (m *StringTable) Size() (n int) {
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for _, b := range m.Strings {
			l = len(b)
			n += 1 + l + sovOsmformat(uint64(l))
		}
	}
	return n
}

func (m *Info) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsmformat(uint64(m.Version))
	n += 1 + sovOsmformat(uint64(m.Timestamp))
	n += 1 + sovOsmformat(uint64(m.Changeset))
	n += 1 + sovOsmformat(uint64(m.Uid))
	n += 1 + sovOsmformat(uint64(m.UserSid))
	n += 2
	return n
}

func (m *DenseInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Version) > 0 {
		l = 0
		for _, e := range m.Version {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Timestamp) > 0 {
		l = 0
		for _, e := range m.Timestamp {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Changeset) > 0 {
		l = 0
		for _, e := range m.Changeset {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Uid) > 0 {
		l = 0
		for _, e := range m.Uid {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.UserSid) > 0 {
		l = 0
		for _, e := range m.UserSid {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Visible) > 0 {
		n += 1 + sovOsmformat(uint64(len(m.Visible))) + len(m.Visible)*1
	}
	return n
}

func (m *ChangeSet) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovOsmformat(uint64(*m.Id))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	n += 1 + sozOsmformat(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsmformat(uint64(l))
	}
	n += 1 + sozOsmformat(uint64(m.Lat))
	n += 1 + sozOsmformat(uint64(m.Lon))
	return n
}

func (m *DenseNodes) Size() (n int) {
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	l = m.Denseinfo.Size()
	n += 1 + l + sovOsmformat(uint64(l))
	if len(m.Lat) > 0 {
		l = 0
		for _, e := range m.Lat {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Lon) > 0 {
		l = 0
		for _, e := range m.Lon {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.KeysVals) > 0 {
		l = 0
		for _, e := range m.KeysVals {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	return n
}

func (m *Way) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOsmformat(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsmformat(uint64(l))
	}
	if len(m.Refs) > 0 {
		l = 0
		for _, e := range m.Refs {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	return n
}

func (m *Relation) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovOsmformat(uint64(*m.Id))
	}
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsmformat(uint64(l))
	}
	if len(m.RolesSid) > 0 {
		l = 0
		for _, e := range m.RolesSid {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Memids) > 0 {
		l = 0
		for _, e := range m.Memids {
			l += sozOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovOsmformat(uint64(e))
		}
		n += 1 + sovOsmformat(uint64(l)) + l
	}
	return n
}

func sovOsmformat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOsmformat(x uint64) (n int) {
	return sovOsmformat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HeaderBlock) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bbox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bbox == nil {
				m.Bbox = &HeaderBBox{}
			}
			if err := m.Bbox.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredFeatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredFeatures = append(m.RequiredFeatures, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFeatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalFeatures = append(m.OptionalFeatures, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writingprogram", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Writingprogram = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Source = &s
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsmosisReplicationTimestamp", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OsmosisReplicationTimestamp = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsmosisReplicationSequenceNumber", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OsmosisReplicationSequenceNumber = &v
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsmosisReplicationBaseUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.OsmosisReplicationBaseUrl = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderBBox) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderBBox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderBBox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Left = int64(v)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Right = int64(v)
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Top = int64(v)
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bottom", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Bottom = int64(v)
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("left")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("right")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("top")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("bottom")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveBlock) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StringTable.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primitivegroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Primitivegroup = append(m.Primitivegroup, PrimitiveGroup{})
			if err := m.Primitivegroup[len(m.Primitivegroup)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granularity", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Granularity = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateGranularity", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DateGranularity = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatOffset", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LatOffset = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LonOffset", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LonOffset = &v
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("stringtable")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveGroup) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dense", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dense.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ways = append(m.Ways, Way{})
			if err := m.Ways[len(m.Ways)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, Relation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changesets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changesets = append(m.Changesets, ChangeSet{})
			if err := m.Changesets[len(m.Changesets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringTable) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, make([]byte, postIndex-iNdEx))
			copy(m.Strings[len(m.Strings)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changeset", wireType)
			}
			m.Changeset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Changeset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
			m.UserSid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UserSid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Version = append(m.Version, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Version = append(m.Version, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Timestamp = append(m.Timestamp, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Timestamp = append(m.Timestamp, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Changeset = append(m.Changeset, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Changeset = append(m.Changeset, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Changeset", wireType)
			}
		case 4:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Uid = append(m.Uid, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Uid = append(m.Uid, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
		case 5:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UserSid = append(m.UserSid, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UserSid = append(m.UserSid, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Visible = append(m.Visible, bool(v != 0))
				}
			} else if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Visible = append(m.Visible, bool(v != 0))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeSet) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Id = int64(v)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Lat = int64(v)
			hasFields[0] |= uint64(0x00000002)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Lon = int64(v)
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lat")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lon")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseNodes) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Id = append(m.Id, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Id = append(m.Id, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denseinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Denseinfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lat = append(m.Lat, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lat = append(m.Lat, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
		case 9:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lon = append(m.Lon, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lon = append(m.Lon, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
		case 10:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeysVals = append(m.KeysVals, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeysVals = append(m.KeysVals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysVals", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Way) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Way: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Way: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Refs = append(m.Refs, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Refs = append(m.Refs, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsmformat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RolesSid = append(m.RolesSid, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RolesSid = append(m.RolesSid, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RolesSid", wireType)
			}
		case 9:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Memids = append(m.Memids, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Memids = append(m.Memids, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Memids", wireType)
			}
		case 10:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsmformat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Relation_MemberType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsmformat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (Relation_MemberType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else if wireType == 0 {
				var v Relation_MemberType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (Relation_MemberType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsmformat(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsmformat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOsmformat(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOsmformat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOsmformat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOsmformat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOsmformat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOsmformat(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOsmformat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOsmformat   = fmt.Errorf("proto: integer overflow")
)
